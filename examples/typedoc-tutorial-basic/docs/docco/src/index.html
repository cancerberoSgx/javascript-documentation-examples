<!DOCTYPE html>

<html>
<head>
  <title>index.ts</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>index.ts</h1>
        

        
      </div>

      
        
        
        
      
        
        <p><span class="invisible"></p>

        
          <div class='highlight'><pre><span class="hljs-keyword">import</span> { Stream } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { EventEmitter } <span class="hljs-keyword">from</span> <span class="hljs-string">'events'</span>;
<span class="hljs-keyword">interface</span> FooApplication{}
<span class="hljs-keyword">interface</span> FooOptions{}
<span class="hljs-keyword">class</span> GameContainer{}
<span class="hljs-keyword">interface</span> FileAccess{}</pre></div>
        
      
        
        <p></span></p>

        
      
        
        <h1 id="typedoc-tutorial">TypeDoc Tutorial</h1>

        
      
        
        <p>In this tutorial you will learn how to document your <a href="https://www.typescriptlang.org/">TypeScript</a> 
projects using <a href="http://typedoc.org/">TypeDoc</a>, a tool that will extract descriptions from your TypeScript 
source comments and generate a well organized and pretty HTML documentation. </p>

        
      
        
        <p>It is required that you know the basics of TypeScript, but besides that, this tutorial will start from scratch. </p>

        
      
        
        <h2 id="table-of-contents">Table of Contents</h2>

        
      
        
        <div id="generated-toc"></div>

        
      
        
        <h2 id="typedoc-introduction">TypeDoc Introduction</h2>

        
      
        
        <p>This section is oriented to those with no experience with any JsDoc-like technology. If you are familiar with JsDoc, javadoc or related technology, skip it and proceed to <a href="#classes-and-interfaces">next section</a>. </p>

        
      
        
        <p>TypeDoc is an API documentation generator for TypeScript projects, similar 
to <a href="http://usejsdoc.org/">JsDoc</a> or <a href="https://en.wikipedia.org/wiki/Javadoc">javadoc</a>.</p>

        
      
        
        <p>Basically, you add documentation comments directly to your source code, right alongside the code itself. The TypeDoc tool will scan your source code and generate an HTML documentation website for you.</p>

        
      
        
        <p>In general you will be documenting entities like classes, interfaces, methods, functions, etc. </p>

        
      
        
        <p>Although configurable, TypeDoc will generate documentation of everything in your source, even things that are not documented like their names, types and relationships. </p>

        
      
        
        <p>Unlike JsDoc, with TypeDoc you only take care of descriptions and you never document types, names member modifiers or any other data that is already expressed in the TypeScript code: that work is automatically performed by the TypeDoc tool. </p>

        
      
        
        <h3 id="descriptions">Descriptions</h3>

        
      
        
        <p>For adding a description to some entity in the code you must use special comments that must be placed immediately <em>before</em> the code being documented. </p>

        
      
        
        <p>Each comment must start with a <code>/**</code> sequence in order to be recognized by TypeDoc. Comments beginning with <code>//</code>, <code>/*</code>, <code>/***</code>, or more than 3 stars will be ignored. Example: </p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/** The sweet and fleshy product of a tree or other plant. */</span>
<span class="hljs-keyword">class</span> Fruit {

}</pre></div>
        
      
        
        <p>Here you can see the output generated by TypeDoc: <a href="../../classes/fruit.html">classes/fruit</a>.</p>

        
      
        
        <p>TypeDoc will format descriptions with MarkDown, in concrete it uses the <a href="https://github.com/chjj/marked">Marked</a> markdown parser and <a href="https://github.com/isagalaev/highlight.js">HighlightJS</a> to highlight code blocks within markdown sections. In the following example, notice how we use markdown to write multiple paragraphs, bold text and an example code snippet:</p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/**
 * Responsible of minify given string containing JavaScript code. By default it uses the foo-bar minimization algorithm. 
 * 
 * **Warning: if you don't specify an output in the configuration your input file will be overridden !**
 * 
 * Basic usage example: 
 * 
 * ```ts
 * import {minify} from 'foobar-minify';
 * const config = {
 *   input: readFileSync('dist/awesome-app.js'), 
 *   output: createWriteStream('dist/awesome-app.min.js')
 * }
 *   minify(config);
 * ```
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minify</span>(<span class="hljs-params"></span>)</span>{}</pre></div>
        
      
        
        <p>Here you can see the output generated by TypeDoc: <a href="../../globals.html#minify">globals.html#minify</a>.</p>

        
      
        
        <h3 id="tags">Tags</h3>

        
      
        
        <p>TypeDoc will extract the information of entities found in TypeScript source code such as classes, methods, functions, names, types, etc, and will associating the comment descriptions, if any, to each entity. But sometimes, we want to describe more than one entity in a comment, or often, a high level concept that the TypeScript language simply doesn’t support as we will see. In those cases we use what we call <strong>comment <code>tags</code></strong> (also known as comment annotations). </p>

        
      
        
        <p>Tags are special words in comment descriptions that start with <code>@</code>. For example, when describing a function, we must describe its subparts like parameters and return value and for doing that in the same comment, we use tags for identify each subpart, for example: </p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/**
 * Starts the application with given options
 * @param options options to start the application with
 * @param app the application to start
 * @returns a promise resolved true when the application is ready
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startApplication</span>(<span class="hljs-params">app: FooApplication, options: FooOptions</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">boolean</span>&gt;

</span></pre></div>
        
      
        
        <p>Here you can see the output generated by TypeDoc: <a href="../../globals.html#startapplication">globals.html#startapplication</a>.</p>

        
      
        
        <p>As you can see, we described the entire method declaration in a single comment, starting with the method description, its parameters and last the return value. We needed to use tags <code>@param</code> and <code>@returns</code> to indicate which part of the method each description is documenting. </p>

        
      
        
        <p>The complete list of tags supported by TypeDoc is here: <a href="http://typedoc.org/guides/doccomments/">list of tags</a>. </p>

        
      
        
        <h2 id="classes-and-interfaces">Classes and Interfaces</h2>

        
      
        
        <p>In the following example we focus only on classes and interfaces, later we will see <a href="#properties">properties</a> and <a href="#methods-and-functions">methods</a> documentation in detail. It declares an interface which is <a href="https://www.typescriptlang.org/docs/handbook/generics.html">generic</a> and a class implementing it.</p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/**
 * A shape is the form of an object or its external boundary, outline
 * @param U The unit used to measure the properties of this type of shape
 */</span>
<span class="hljs-keyword">interface</span> Shape&lt;U <span class="hljs-keyword">extends</span> Unit &gt; {
  area():<span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> Unit {}
<span class="hljs-keyword">interface</span> Centimeter <span class="hljs-keyword">extends</span> Unit {} 
<span class="hljs-comment">/**
 * The Shape implementation used in Foo component to represent Bar
 */</span>
<span class="hljs-keyword">class</span> MyCustomRectangle <span class="hljs-keyword">implements</span> Shape&lt;Centimeter&gt; {
  <span class="hljs-keyword">private</span> side:<span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">public</span> area():<span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.side*<span class="hljs-keyword">this</span>.side;
  }
}</pre></div>
        
      
        
        <p>This is the output of the interface: <a href="../../interfaces/shape.html">interfaces/shape</a> and this is the output of the class: <a href="../../classes/mycustomrectangle.html">classes/mycustomrectangle</a></p>

        
      
        
        <p>Some details about what we just did:</p>

        
      
        
        <ul>
<li>We used the double star comment (<code>/**</code>) just before the interface declaration</li>
<li>The first line of the comment is the interface description</li>
<li>We documented the interface’s generic type <code>U</code> using the tag <code>@param</code> then the name of the type parameter <code>U</code> followed by its description. </li>
</ul>

        
      
        
        <p><strong>TIP: classes vs interfaces in documentation</strong> . If you are working with interfaces (hiding implementation details from your users), then you should <strong>only document interfaces instead of classes</strong>. Document classes only to give details about the implementation, if that’s what you want, but <strong>make sure you don’t repeat information that’s already in the interface</strong></p>

        
      
        
        <h2 id="properties-and-variables">Properties and Variables</h2>

        
      
        
        <p>You can describe properties of classes, interfaces, objects, enums, etc by adding a <code>/**</code> comment just before the property declaration. The same for variables declared with <code>var</code>, <code>const</code> or <code>let</code>. </p>

        
      
        
        <p>In the following example we document properties of several entities, including <code>interface</code>, <code>class</code>, <code>enum</code>, <code>type</code> and variable declarations:</p>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">interface</span> GameUnit {
  <span class="hljs-comment">/** unique id of this unit in the board */</span>
  id: <span class="hljs-built_in">string</span>
  <span class="hljs-comment">/** 
   * Status of this unit in the board 
   * 
   */</span>
  status: {
    <span class="hljs-comment">/** must be between 0 and 1 */</span>
    health: <span class="hljs-built_in">number</span>, 
    <span class="hljs-comment">/** the ids of units killed by this unit */</span>
    kills: <span class="hljs-built_in">number</span>[]
  }
}
<span class="hljs-keyword">enum</span> GameState {
  <span class="hljs-comment">/** game started but user paused it */</span>
  paused, 
  <span class="hljs-comment">/** victory condition reached */</span>
  ended, 
  <span class="hljs-comment">/** game is being played right now */</span>
  playing, 
  <span class="hljs-comment">/** game didn't started yet - player is choosing initial race? */</span>
  notStarted,
}
<span class="hljs-keyword">class</span> Game {
  <span class="hljs-comment">/**
   * State of the game at this moment
   */</span>
  state: GameState
  config: GameConfiguration

  <span class="hljs-keyword">private</span> _currentTime: <span class="hljs-built_in">Date</span>
  <span class="hljs-comment">/** the actual current time elapsed since this game was started not counting when it was paused */</span>
  <span class="hljs-keyword">get</span> currentTime():<span class="hljs-built_in">Date</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._currentTime; }
  <span class="hljs-keyword">set</span> currentTime(value:<span class="hljs-built_in">Date</span>) { <span class="hljs-keyword">this</span>._currentTime = value; }
  <span class="hljs-comment">/** default board with and height if none is provided */</span>
  <span class="hljs-keyword">static</span> DEFAULT_STATE = GameState.notStarted

}
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> GameConfiguration = {
  <span class="hljs-comment">/** number of columns the board haves */</span>
  boardWith?: <span class="hljs-built_in">number</span>
  <span class="hljs-comment">/** number of rows the board haves */</span>
  boardHeight?: <span class="hljs-built_in">number</span>
  <span class="hljs-comment">/** board fog of war initial configuration */</span>
  fogOfWar?: <span class="hljs-built_in">string</span>[]
}
<span class="hljs-comment">/** the global game singleton */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> gameContainer = <span class="hljs-keyword">new</span> GameContainer()</pre></div>
        
      
        
        <p>TypeDoc Output: </p>

        
      
        
        <ul>
<li>interface Unit <a href="../../interfaces/gameunit.html">interfaces/gameunit.html</a> </li>
<li>Class game <a href="../../classes/game.html">classes/game.html</a> </li>
<li>enum GameState <a href="../../enums/gamestate.html">enums/gamestate.html</a></li>
<li>type declaration GameConfiguration <a href="../../globals.html#gameconfiguration">globals.html#gameconfiguration</a></li>
</ul>

        
      
        
        <p>Notes: </p>

        
      
        
        <ul>
<li>We didn’t document types, names or modifiers of the properties, typedoc will do that automatically. </li>
<li>We even added descriptions to <code>Unit.status</code> property which type is an object literal. Is unlikely you want to document the properties of object literals like that (you probably want to define interfaces) but just in case it’s supported. ee how it looks in the output: <a href="../../interfaces/gameunit.html#status">interfaces/gameunit.html#status</a></li>
<li>Property accessors are documented like a property and is not necessary to document both the setter and the getter, is enough to document only one of them: <a href="../../classes/game.html#currenttime">classes/game.html#currenttime</a> </li>
<li>At the end of the example we documented a global variable, although is unlikely to document variables, it’s also possible : <a href="../../globals.html#gamecontainer">globals.html#gamecontainer</a> . </li>
</ul>

        
      
        
        <h2 id="methods-and-functions">Methods and Functions</h2>

        
      
        
        <p>Methods and Functions could be the most complex parts of document, because thy imply parameters and return values. For these, you will be using two tags: <code>@param</code> and <code>@return</code> or <code>@returns</code> respectively. </p>

        
      
        
        <p>Because documenting methods and functions is the same thing, here we will say just “methods” but everything applies to both. </p>

        
      
        
        <p>The syntax of a method or function TypeDoc comment is as follows: first the method description and then the rest. The order of parameters is not important.</p>

        
      
        
        <p>Let’s go straight to an example that shows a lot of combinations regarding this:</p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/**
 * @param T the type of access this file has on IO
 */</span>
<span class="hljs-keyword">class</span> File&lt;T <span class="hljs-keyword">extends</span> FileAccess&gt; {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">fs:<span class="hljs-built_in">number</span></span>) {} <span class="hljs-comment">// constructor, no docs</span>
  <span class="hljs-comment">/**
   * Creates a new file in given path and given content
   * @param path absolute path of the file to create
   * @param content content of the new file or empty file if nothing given
   * @param T the type of access created file will have on IO
   * @return a new description of the access type the new file has
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create&lt;T <span class="hljs-keyword">extends</span> FileAccess&gt;(path: <span class="hljs-built_in">string</span>, content?: <span class="hljs-built_in">string</span> | Stream, 
    permissions: <span class="hljs-built_in">string</span> = <span class="hljs-string">'666'</span>): T {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Internal method used by foobar
   * @param interval how often file is read in the polling
   * @param predicate polling will end when true
   */</span>
  <span class="hljs-keyword">private</span> poll(interval:<span class="hljs-built_in">number</span>, predicate: <span class="hljs-function">(<span class="hljs-params">t: T</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>):<span class="hljs-built_in">void</span> {}
}
<span class="hljs-keyword">interface</span> FileEmitter&lt;T&gt; <span class="hljs-keyword">extends</span> EventEmitter {
  <span class="hljs-comment">/** registers the listener to be notified **before** a file is about to change. The change will be hold until all listeners returned promises are resolved. If any listener reject the promise the file modification action will be canceled. */</span>
  on(event: <span class="hljs-string">'before-file-modification'</span>, listener: <span class="hljs-function">(<span class="hljs-params">f: File&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt;): <span class="hljs-keyword">this</span>
  on(event: <span class="hljs-string">'after-file-modification'</span>, listener: <span class="hljs-function">(<span class="hljs-params">f: File&lt;T&gt;, previousContent: Buffer</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>
}
<span class="hljs-comment">/**
 * List children of given folder
 * @param FAT target files access type 
 * @param options.force force read operation  even if files are busy
 * @param options.recursive list all files recursively
 * @return if given path points to a folder returns a list of direct children Files,. Returns null otherwise
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listFiles</span>&lt;<span class="hljs-title">FAT</span> <span class="hljs-title">extends</span> <span class="hljs-title">FileAccess</span>&gt;(<span class="hljs-params">path: <span class="hljs-built_in">string</span>, 
  options?: {force: <span class="hljs-built_in">boolean</span>, recursive: <span class="hljs-built_in">boolean</span>}</span>)
  : <span class="hljs-title">File</span>&lt;<span class="hljs-title">FAT</span>&gt;[] | <span class="hljs-title">undefined</span> </span>{ <span class="hljs-keyword">return</span> [] }</pre></div>
        
      
        
        <p>Notes: </p>

        
      
        
        <ul>
<li>The class <code>File</code> defines a constructor which is not documented but the output still is generated: <a href="../../classes/file.html#constructor">classes/file.html#constructor</a></li>
<li>The static method <code>create</code> that is generic and has a parameter <code>permissions</code> with a default value. Notice how we document the generic type <code>T</code> using <code>@param</code> : <a href="../../classes/file.html#create">classes/file.html#create</a></li>
<li>And last but not least, the function <code>listFiles</code> which shows how to document the complex parameter object <code>options</code> and has a generic parameter <code>FT</code>: <a href="../../globals.html#listfiles">globals.html#listfiles</a> </li>
</ul>

        
      
        
        <p><strong>Important</strong>: Again, as with anynthing in TypeDoc we never describe information already defined in the TypeScript code, like names, types and modifiers like if a parameter is optional, default parameter values, if a method is private or static, etc. </p>

        
      
        
        <h3 id="parameters-and-return-type">Parameters and Return Type</h3>

        
      
        
        <p>As with anything in TypeDoc documenting parameters is optional. For describing a parameter we use the syntax <code>@param PARAMETER_NAME</code> where <code>PARAMETER_NAME`</code>must match with one of the names of the parameters in the method or function signature. </p>

        
      
        
        <p>Unfortunately the TypeScript compiler won’t validate this so we must careful when renaming parameters. </p>

        
      
        
        <p>TIP: if you use the “Rename” refactor tool of typescript for renaming a parameter, the @param will be also renamed so make sure you always use that tool instead of renaming manually. </p>

        
      
        
        <p>For return values, you can use <code>@return</code> or <code>@returns</code> and then the description of what is returned when the method or function is invoked. </p>

        
      
        
        <p><strong>TIP</strong>: Make sure <code>@param</code> and <code>@returns</code> descriptions add value. Don’t write them just because of the sake of writing. If you choose well your methods and parameter names descriptions often arenot needed. If you omit documenting a parameter or return type, its documentation will be still generated by TypeDoc (even if its type is <code>void</code> or <code>any</code>)</p>

        
      
        
        <h3 id="overrides">Overrides</h3>

        
      
        
        <p>In the previous example, the interface <code>FileEmitter</code> overrides the method <code>on()</code> of its parent interface and declare two signatures. Take moment to see how TypeDoc generates the output for this case: <a href="../../interfaces/fileemitter.html#on">interfaces/fileemitter.html#on</a></p>

        
      
        
        <h2 id="modules">Modules</h2>

        
      
        
        <p>TODO</p>

        
      
        
        <h2 id="events">Events</h2>

        
      
        
        <p>TL;DR : Three techniques to represent and document events with TypeDoc are presented in this section, each of them with its own pros and cons. If you want to play safe and do what the majority of TypeScript developers are doing, then use technique 1. If you want to represent your events optimally then go technique 3. </p>

        
      
        
        <p>First of all sorry for the long section, but really I don’t think there is A way of declaring and documenting events today so I needed to be detailed here. </p>

        
      
        
        <p>JavaScript and TypeScript programming languages don’t support the concept of events. Nevertheless, events usually they are an important part of APIs. This is why many technologies oriented to documentation, like TypeDoc, JsDoc, YuiDoc, EsDoc, support the concept of events using tags like <code>@event</code>, <code>@trigger</code>, <code>@emit</code>, <code>@listen</code>, etc.</p>

        
      
        
        <p>One common pattern to semantically define events in these technologies, is treating <strong>events as methods</strong>, where then the event is a member of the emitter, the event name acts as member name and the listener signature is the method signature. But again, this is not written in stone and there are several ways of represent events, depending on the scenario and the technology, as we will see. </p>

        
      
        
        <p>Let’s agree on the objective. The tags <code>@event</code>, <code>@emit</code> or <code>@listen</code> are, BTW missleading. What we really want to declare and document when we talk about “events” is the relationship that exists between an <strong>event name</strong>, an <strong>emitter</strong> and the protocol used to emit: the <strong>listener signature</strong>. The objectvie is to document the relationship that exists between those three things (not just an event name).</p>

        
      
        
        <p>We will present three different ways of accomplish this, trying to describe objects that emit two events <code>&#39;open&#39;</code> and ‘<code>data&#39;</code> and extends node.js <code>EventEmitter</code> (Our example is a simplified fragment of the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v8/index.d.ts#L5292">official node.js type declaration</a> : </p>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">interface</span> Readable0 <span class="hljs-keyword">extends</span> EventEmitter {
  addListener(event: <span class="hljs-string">'data'</span>, listener: <span class="hljs-function">(<span class="hljs-params">chunk: Buffer | <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
  addListener(event: <span class="hljs-string">'error'</span>, listener: <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
}</pre></div>
        
      
        
        <h3 id="technique-1-add-event-to-method-descriptions">Technique 1: add @event to method descriptions</h3>

        
      
        
        <p>This technique is just adding the <code>@event</code> tag to each <code>addListener</code> signature: </p>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">interface</span> Readable1 <span class="hljs-keyword">extends</span> EventEmitter {
  <span class="hljs-comment">/** 
   * Emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer.
   * @event
   */</span>
  addListener(event: <span class="hljs-string">'data'</span>, listener: <span class="hljs-function">(<span class="hljs-params">chunk: Buffer | <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
  <span class="hljs-comment">/** 
   * Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure
   * @event
   */</span>
  addListener(event: <span class="hljs-string">'error'</span>, listener: <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
}</pre></div>
        
      
        
        <p>This is the output <a href="../../interfaces/readable1.html">interfaces/readable1.html</a> . As you can see our interface shows now, instead of a method, an event.</p>

        
      
        
        <p>It’s relevant to note that this technique takes advantage of explicit method overloading done by TypeScript developers, to ensure method calls match signatures exactly. Since there is a signature for each event name (with a parameter default value being the event name) this more or less describe the event names and corresponding listener signatures. The <code>@event</code> tag just mark the methods visually so we know those signatures contain information about events. </p>

        
      
        
        <h3 id="technique-2-add-event-to-static-properties">Technique 2: add @event to static properties</h3>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">class</span> Readable2 <span class="hljs-keyword">extends</span> EventEmitter { 
  <span class="hljs-comment">/** 
   * Emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer.
   * @event
   */</span>
  <span class="hljs-keyword">static</span> EVENT_DATA:<span class="hljs-string">'data'</span> = <span class="hljs-string">'data'</span>;
  <span class="hljs-comment">/** 
   * Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure
   * @event
   */</span>
  <span class="hljs-keyword">static</span> EVENT_ERROR:<span class="hljs-string">'error'</span> = <span class="hljs-string">'error'</span>;
  addListener(event: <span class="hljs-keyword">typeof</span> Readable2.EVENT_DATA, listener: <span class="hljs-function">(<span class="hljs-params">chunk: Buffer | <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
  addListener(event: <span class="hljs-keyword">typeof</span> Readable2.EVENT_ERROR, listener: <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-keyword">this</span>;
  addListener(event: <span class="hljs-built_in">string</span> , listener: <span class="hljs-built_in">any</span>): <span class="hljs-keyword">this</span> {<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}</pre></div>
        
      
        
        <p>This is the output <a href="../../classes/readable2.html">classes/readable2.html</a>.</p>

        
      
        
        <p>Declare event names as constants static properties. Add the <code>@event</code> tag to them. We keep overloading the <code>addListener</code> method to force typechecking when calling it and the trick for it to work declare the type of the constants and parameters as a string literal: this <code>static EVENT_DATA:&#39;data&#39; = &#39;data&#39;;</code> together with this: <code>event: typeof Readable2.EVENT_DATA</code>.</p>

        
      
        
        <p>Events are still encapsulated as member of the class and the relationship between event names and listener signatures is sill maintained and visible. </p>

        
      
        
        <p><a href="http://typedoc.org/api/classes/converter.html">TypeDoc documentation</a> uses a technique similar to this one. </p>

        
      
        
        <h3 id="technique-3-add-event-to-listener-signatures">Technique 3: add @event to listener signatures</h3>

        
      
        
        <p>This technique is my favorite IMO represents events optimally in typedoc output, but also it could be a little bit hard to accomplish. Is similar to technique 1 but we don’t add the @event tag to methods (which is confusing) but to listener type declarations that are outside the class. </p>

        
          <div class='highlight'><pre>


<span class="hljs-comment">/** 
 * Emitted whenever the stream is relinquishing ownership of a chunk of data to a consumer.
 * @asMemberOf Readable3
 * @event
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span> (<span class="hljs-params">chunk: Buffer | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">void</span></span>; 
<span class="hljs-comment">/** 
 * Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure
 * @asMemberOf Readable3
 * @event
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span> (<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>): <span class="hljs-title">void</span></span>; 
<span class="hljs-keyword">interface</span> Readable3 <span class="hljs-keyword">extends</span> EventEmitter {
  addListener(event: <span class="hljs-string">'data'</span>, listener: <span class="hljs-keyword">typeof</span> data): <span class="hljs-keyword">this</span>;
  addListener(event: <span class="hljs-string">'error'</span>, listener: <span class="hljs-keyword">typeof</span> error): <span class="hljs-keyword">this</span>;
}</pre></div>
        
      
        
        <p>See the output: This is the output <a href="../../interfaces/readable3.html">interfaces/readable3.html</a>.</p>

        
      
        
        <h3 id="comparison">Comparison</h3>

        
      
        
        <p>Why do I consider 3 better than 1 and 2: </p>

        
      
        
        <ul>
<li>It doesn’t pollute (or force me to) the members of the class/interface. Technique 1 transform the method <code>addListener</code> to an event. The method disappear and the event named `addListener doesn’t make any sense. Technique 2 force me to create event name static properties</li>
<li>But most important I think, 1 and 2 fail because relationship between event names and listener signature is hidden inside a method method overriding.The event names appear all stacked, as parameter types, all stacked below sommething called “addListener” which is very confusing. This 3rd technique outputs individual events with their correct names together with the listener signature all in an individual event member desattached from <code>addListener</code> </li>
<li>Also it allows me to declare all this information using interfaces. I’ve also  realized also that encapsulating  listener type in a declaration is a good idea to enforce typecheking when there are lots of events with complex different listener signatures</li>
</ul>

        
      
        
        <p>I will briefly explain it. The objectives are not contimate our classes with artificial entities ,maintain the relationship between event names and listener signatures and enforce types on addListener call</p>

        
      
        
        <p>Unfortunately it requires the TypeDoc plugin <a href="https://github.com/cancerberoSgx/typedoc-plugins-of-mine/tree/master/plugins/typedoc-plugin-as-member-of">as-member-of</a>. Basically what we are doing is declaring the listener signature outside the class as a function type and then instructing the plugin to move as a member of the interface. Because it has the @event tag it will be converted to an event member of the interface. More details in the plugin page. </p>

        
      
        
        <h2 id="referencing">Referencing</h2>

        
      
        
        <p>When we are describing an entity sometimes we want to reference another entity. For example, when describing the method <code>Wind.blow()</code> I want to write a link that points to the class <code>Ocean</code> so users can quickly navigate while reading its description. That’s what we call referencing. </p>

        
      
        
        <p>With TypeDoc is very easy to achieve this, you just put the name of the referenced entity between double squared brackets. In the previous example would be [[Ocean]].</p>

        
      
        
        <h3 id="absolute-vs-relative-references">Absolute vs. relative references</h3>

        
      
        
        <p>You can reference any entity that has a comment like classes, interfaces, methods, functions, properties, etc. You cannot reference a method parameter because it doesn’t contain its own comment: the parameter description is inside a method or function comment. </p>

        
      
        
        <p>Also take in account that a name can be repeated, for example, two classes can contain methods with the same name, or two modules contain classes with the same name. In those cases, the closest entity will takes precedence if we need to reference the external reference we need to use absolute names. Example:</p>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">interface</span> Car {
  <span class="hljs-comment">/** 
   * Once started the engine will turn off only when the 
   * car travel all the [[Route.size]]
   */</span>
  engine:Engine
  size: <span class="hljs-built_in">number</span>
  <span class="hljs-comment">/** 
   * Put in march this cart by turning on its [[engine]] 
   */</span>
  start()
}
<span class="hljs-keyword">interface</span> Route {
  size:<span class="hljs-built_in">number</span>[][]
}
<span class="hljs-keyword">interface</span> Engine{}</pre></div>
        
      
        
        <p>Notes:</p>

        
      
        
        <ul>
<li>In <code>start</code> method’s description, we just used <code>[[engine]]</code> since that property is in the same class: <a href="../../interfaces/car.html#start">interfaces/car.html#start</a></li>
<li>But in <code>engine</code> property description, for referencing the <code>Route</code>‘s <code>size</code> property, we needed to use its absolute name <code>Route.size</code> since <code>Car</code> already has a property with that name: <a href="../../interfaces/car.html#engine">interfaces/car.html#engine</a></li>
</ul>

        
      
        
        <h3 id="check-for-broken-references">Check for broken references</h3>

        
      
        
        <p>if you use a lot of references, you can run the command line tool with the <code>--listInvalidSymbolLinks</code> argument: </p>

        
      
        
        <pre><code> --listInvalidSymbolLinks  Emits a list of broken symbol [[navigation]] links after documentation generation
</code></pre>
        
      
        
        <h2 id="ignoring-things">Ignoring things</h2>

        
      
        
        <p>If we don’t want some class method or other entity to appear at all in TypeDoc output we use the <code>@hidden</code> tag. </p>

        
      
        
        <p><strong>Important</strong>: Put <code>@hidden</code> at the very top of the comment related to the entity you want to ignore. </p>

        
      
        
        <p>You can ignore any entity that can be documented with its own comment, for example classes, methods, properties, etc. But you can’t ignore parameters or return values because these doesn’t have its own comment. </p>

        
      
        
        <p>In the following example, the output will only contain <code>method2()</code> but not <code>method1()`</code>: </p>

        
          <div class='highlight'><pre>

<span class="hljs-keyword">interface</span> SomeThingsAreIgnored {
  <span class="hljs-comment">/**
   * @hidden
   * this comment should be ignored
   * 
   */</span>
  method1():<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-comment">/**
   * this comment shouldn't be ignored
   */</span>
  method2():<span class="hljs-built_in">string</span>;
}</pre></div>
        
      
        
        <p>Here you can see the output generated by TypeDoc: <a href="../../interfaces/somethingsareignored.html">interfaces/somethingsareignored</a>.</p>

        
      
        
        <p>The following example makes TypeDoc to ignore the whole class: </p>

        
          <div class='highlight'><pre>

<span class="hljs-comment">/** @hidden */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassTotallyIgnored {
  color:<span class="hljs-built_in">string</span>;
}</pre></div>
        
      
        
        <p>Here you can see the output generated by TypeDoc: <a href="../../classes/classtotallyignored.html">classes/classtotallyignored</a>.</p>

        
      
        
        <h3 id="filter-non-public-or-non-exported-entities-globally">Filter non public or non exported entities globally</h3>

        
      
        
        <p>You can also configure TypeDoc tool to ignore all entities that are not public or all entities that are not exported. For that you must use the configuration options: </p>

        
      
        
        <pre><code class="lang-sh">--exclude                 Define patterns <span class="hljs-keyword">for</span> excluded files when specifying paths.
--excludeExternals        Prevent externally resolved TypeScript files from being documented.
--excludeNotExported      Prevent symbols that are not exported from being documented.
--excludePrivate          Ignores private variables and methods
--excludeProtected        Ignores non exported things
</code></pre>

        
      
        
        <h2 id="configuration">Configuration</h2>

        
      
        
        <p><strong>WIP</strong></p>

        
      
        
        <ul>
<li>all options should be in <a href="http://typedoc.org/guides/usage/">http://typedoc.org/guides/usage/</a></li>
</ul>

        
      
        
        <h3 id="configuration-files">Configuration files</h3>

        
      
        
        <p>Instead of passing all configuration as command line arguments, you can create a <code>typedocconfig.js</code> or <code>typedocconfig.ts</code> file (the name is not important) with the configuration properties in it and then call <code>typedoc --options ./typedocconfig.ts</code>. Example of <code>typedocconfig.ts</code> file: </p>

        
      
        
        <pre><code class="lang-typescript"><span class="hljs-built_in">module</span>.exports = {
  src: [
    <span class="hljs-string">'./src/index.ts'</span>,
  ],
  mode: <span class="hljs-string">'file'</span>,
  includeDeclarations: <span class="hljs-literal">true</span>,
  tsconfig: <span class="hljs-string">'tsconfig.json'</span>,
  out: <span class="hljs-string">'./tutorial-output'</span>,
  excludePrivate: <span class="hljs-literal">true</span>,
  excludeProtected: <span class="hljs-literal">true</span>,
  excludeExternals: <span class="hljs-literal">true</span>,
  readme: <span class="hljs-string">'README.md'</span>,
  name: <span class="hljs-string">'my-cool-project'</span>,
  ignoreCompilerErrors: <span class="hljs-literal">true</span>,
  plugin: <span class="hljs-string">'none'</span>,
  listInvalidSymbolLinks: <span class="hljs-literal">true</span>,
};
</code></pre>

        
      
        
        <p>Since configuration is declared as JavaScript / TypeScript file it’s easy to implement extends. For example, this configuration extends previous one and will use <a href="https://github.com/tgreyjs/typedoc-plugin-markdown">typedoc-plugin-markdown</a> to generate Markdown output: </p>

        
      
        
        <pre><code class="lang-typescript"><span class="hljs-built_in">module</span>.exports = {
  ... <span class="hljs-built_in">require</span>(<span class="hljs-string">'./typedoc.ts'</span>),
  theme: <span class="hljs-string">'markdown'</span>,
  out: <span class="hljs-string">'../tutorial-output/md'</span>,
}; 
</code></pre>

        
      
        
        <h2 id="plugins">Plugins</h2>

        
      
        
        <p>Typedoc is an extensible framework which support easy implementation of plugins that can analyze and transform the input, AST or output. Plugins can extend TypeDoc in several ways, from supporting new tags, parsing comments differently, to generating output in different formats, etc. We will detail how to install and use a TypeDoc plugin, in this case <a href="https://github.com/tgreyjs/typedoc-plugin-markdown">typedoc-plugin-markdown</a> which allow typedoc tool to generate markdown output instead of HTML. </p>

        
      
        
        <p>Install the plugin: </p>

        
      
        
        <pre><code class="lang-sh">npm install --save-dev typedoc-plugin-markdown
</code></pre>

        
      
        
        <p>Installed plugins are loaded automatically by typedoc tool so installing a plugin is all you need to do in order to use it. In other words, after installing a plugin, <code>typedoc</code> tool will load them out of the box when executed so you don’t have to do anything special. If you want to prevent plugins to execute or execute just one plugin from all currently installed you use the <code>--plugin</code> plugin option: </p>

        
      
        
        <p><code>--plugin</code> -  Specify the npm plugins that should be loaded. Omit to load all installed plugins, set to ‘none’ to load no plugins.</p>

        
      
        
        <p>In the particular case of this plugin, as indicated in <a href="https://github.com/tgreyjs/typedoc-plugin-markdown">its documentation</a> we must use <code>--theme markdown</code> to generate Markdown output. But that’s it, as said before we don’t need to use <code>--plugin</code> since it’s loaded automatically: </p>

        
      
        
        <p><code>typedoc --theme markdown --out apidocs src/interfaces.ts</code></p>

        
      
        
        <p>See <a href="https://github.com/TypeStrong/typedoc-site/blob/gh-pages/tutorial-output/md/README.md">generated markdown output</a> for this tutorial code. </p>

        
      
        
        <p><script src="https://cancerberosgx.github.io/raphaeljs-tutorial/generated_toc.js"></script></p>
<style>
h1, h2, h3, h4, h5, h6{
  text-transform: none;
}
.invisible {
  display: none;
}
</style>

        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
